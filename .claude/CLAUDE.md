# プロジェクトルール

## コードチェック

コードの変更後やPR作成前には、以下のコマンドを順番に実行すること:

```bash
cargo fmt      # コードのフォーマット
cargo check    # コンパイルエラーの確認
cargo test     # テストの実行
cargo clippy   # lintチェック
```

コミット前に必ず`cargo fmt`を実行し、全てのチェックがパスすることを確認してからコミット・プッシュする。

## CI ウォッチ

PRをプッシュした後は、CIの結果を確認すること。失敗があれば自分で修正してプッシュする。

```bash
gh pr checks --watch --fail-fast   # CIを完了までウォッチ（失敗時は即終了）
gh run view <run-id> --log         # 失敗時のログ確認
```

- プッシュ後に `gh pr checks --watch --fail-fast` でCIの完了を待つ
- failしたら `gh run view` でログを確認し、原因を調査して修正・再プッシュする

## PRマージ

- PRをマージするときは **squash merge ではなく merge commit** を使うこと
  ```bash
  gh pr merge <pr-number> --merge --delete-branch
  ```
- マージ後は main ブランチに戻って最新を pull すること
  ```bash
  git checkout main && git pull
  ```

## moca lint

`.mc` ファイルを変更・作成した場合は `moca lint <file>` を実行し、警告があれば修正すること。

## ドキュメント

- プロジェクトのドキュメントは `docs/` ディレクトリにあるので、適宜参照すること

## /spec スキルの出力先

- `/spec` スキルで仕様を詰める際、`spec.md` ファイルではなく **GitHub Issue** に仕様を記載すること
- イシューが既にある場合はそのイシューの本文を更新し、なければ新規作成する
- これにより、セッションをまたいでも仕様が参照できるようになる

## Skills

### spec → impl の自動実行

`/spec` スキルで仕様が確定したら、自動的に `/impl` スキルを実行すること。

### impl スキルの設定

`/impl` スキル実行時は以下のルールに従う:

- **確認不要**: 人間への確認は取らず、自律的に実装を進める
- **セルフレビュー**: レビューは自分自身で行う（外部レビューは不要）
- **チェックコマンド**: 各タスク完了後、以下のコマンドを実行する
  ```bash
  cargo fmt      # コードのフォーマット
  cargo check    # コンパイルエラーの確認
  cargo test     # テストの実行
  cargo clippy   # lintチェック
  ```

### PR作成後のフロー

PRを作成した後は以下のフローに従う:

1. **CI watch**: `gh pr checks <PR番号> --watch` でCIの完了を待つ
2. **結果確認**: CI全チェック（check, coverage-report, performance-report）がパスしていることを確認する
3. **マージ確認**: パフォーマンスに大きなデグレがなく、カバレッジも正常であれば、ユーザーにマージしてよいか確認する
4. **マージ実行**: ユーザーの承認後、`gh pr merge <PR番号> --merge` でマージする

## Hostcall に関する制約

- パフォーマンス最適化のために **新しい hostcall を勝手に追加してはいけない**
- hostcall はポータビリティに直結するため、追加は必ずユーザーの明示的な許可を得てから行うこと
- 既存の hostcall の内部実装の改善（インターフェースを変えない最適化）は許可不要

## Performance & Benchmarking

パフォーマンステストは以下の2箇所で構成されている:

- **mocaテストファイル**: `tests/snapshots/performance/*.mc`
- **Rustリファレンス実装・テストハーネス**: `tests/snapshot_tests.rs` 内の `snapshot_performance` 関数（`#[cfg(feature = "jit")]`）

### 新しいパフォーマンステストの追加手順

1. `tests/snapshots/performance/` に `.mc` ファイルを作成する
2. `tests/snapshot_tests.rs` に対応するRustリファレンス実装関数を `#[cfg(feature = "jit")]` 付きで追加する
3. `snapshot_performance` テスト関数内で `run_performance_test` を呼び出して登録する
4. **JIT制約**: テスト内の少なくとも1つの関数がJITコンパイル可能である必要がある。JITが対応しているのは整数/浮動小数点の算術・比較、制御フロー（`Jmp`, `BrIfFalse`, `Ret`）、関数呼び出しのみ。文字列操作、ヒープ操作（vec/map）、ビルトイン関数（`to_string`等）はJIT非対応のため、これらを使う場合はJIT対応のヘルパー関数を別途用意する
5. mocaとRustの出力が完全一致することを確認する

### 実装時の注意事項

1. **出力の一致**: 比較対象の実装間で出力が一致していること
2. **最適化による除去の防止**: コンパイラ最適化で計測対象の処理が除去されないようにする（`black_box`を使用するか、結果を出力する）
3. **ローカルでの事前実行**: コミット前に必ずローカルでベンチマークを実行して確認する（`cargo test snapshot_performance`）

## Language-Specific Notes

### moca

- 戻り値の型は `-> type` 形式を使用する（`: type` ではない）
  - ✅ `fn foo() -> int`
  - ❌ `fn foo(): int`


## イシュー管理

作業中にバグ、改善点、将来のタスクなどを発見した場合は、`gh issue create` でイシューを作成しておくこと。

- 今すぐ直す必要がないものや、スコープ外のものはイシューにして記録する
- 再現手順やコンテキストを含める

## 仕様管理

- 機能の仕様は **GitHub Issue に記載** すること（チャット内だけで仕様を持たない）
- イシューに仕様を書くことで、セッションが変わっても引き継ぎできるようにする
- `/spec` で仕様を詰めた場合も、最終的な仕様はイシューに反映すること

## 大きいタスクの進め方

### 方針のアラインメント

大きいタスクや複雑な実装に取り掛かる前に、`AskUserQuestion` を使ってユーザーと方針をアラインすること。

- 設計上の選択肢がある場合は、選択肢を提示して確認する
- 影響範囲が広い変更は、着手前にアプローチを共有する
- 不明点は推測せず質問する

### フェーズ管理

実装が複数フェーズにまたがる場合は、GitHub のサブイシューで進捗を管理すること。

```bash
gh issue create --title "Phase 1: ..." --body "..." --label "sub-issue"
```

- 親イシューからサブイシューへのリンクを貼る
- 各フェーズの完了時にサブイシューをクローズする
- 進捗が一目でわかるようにする

### 関連イシューの起票

実装の途中で本題からそれるが改善すべき点を見つけた場合は、積極的に `gh issue create` でイシューに起票すること。

- バグ、リファクタリングの機会、技術的負債など
- 今の作業を中断せず、イシューとして記録して後で対応する
- コンテキストや発見の経緯を含める

## デバッグ

デバッグコードをソースに追加する前に、まず既存の CLI オプションを確認すること。

```bash
cargo run -- run --help   # 利用可能なオプション一覧
```

主なダンプ・トレースオプション:

- `--dump-microops` — MicroOp IR をダンプ
- `--trace-jit` — JIT コンパイル・実行のトレースログ

既存オプションで目的を達成できない場合にのみ、一時的なデバッグコードを追加する。

## Investigation Guidelines

ユーザーがシステムの挙動について質問した場合（例: 「なぜXが動かないのか？」）:

- まず、ユーザーが質問している**具体的な機構**を調査する
- 関連するが別の機構に脱線しない
- 調査スコープが不明確な場合は、先に確認する
