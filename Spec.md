# Spec.md

## 1. Goal
- 標準ライブラリ（文字列操作・数学関数）をMocaで実装し、`run`時に自動で読み込まれるようにする

## 2. Non-Goals
- ファイルI/O、ネットワーク機能
- 名前空間付きインポート（`std.math.abs`形式）
- Rustによる低レベル実装
- 大規模な標準ライブラリ

## 3. Target Users
- Mocaユーザーが基本的な文字列操作・数学関数を追加importなしで使えるようにする

## 4. Core User Flow
1. ユーザーが `moca run example.mc` を実行
2. コンパイラが自動的に標準ライブラリを読み込む
3. ユーザーコード内で `abs(-5)` や `str_len("hello")` などがそのまま使える
4. 特別なimport文は不要

## 5. Inputs & Outputs
- **入力**: ユーザーのMocaソースコード
- **出力**: 標準ライブラリ関数が利用可能な状態で実行

## 6. Tech Stack
- 言語: Moca（標準ライブラリ本体）、Rust（コンパイラ修正）
- 埋め込み: `include_str!` マクロでビルド時にバイナリに含める
- テスト: 既存のスナップショットテスト + Mocaサンプルコード

## 7. Rules & Constraints
- 標準ライブラリはすべてMocaで記述する
- 関数はグローバル名前空間に配置（`import`不要）
- ビルド時に `std/` のソースを埋め込む（単一バイナリ配布可能）
- 既存の組み込み関数（print, len, push, pop等）との名前衝突を避ける

## 8. Open Questions
- なし

## 9. Acceptance Criteria
1. `std/prelude.mc` が存在し、標準ライブラリ関数が定義されている
2. `moca run` 実行時に標準ライブラリが自動で読み込まれる
3. ユーザーコードから `abs(-5)` を呼び出して `5` が返る
4. ユーザーコードから `max(3, 7)` を呼び出して `7` が返る
5. ユーザーコードから `min(3, 7)` を呼び出して `3` が返る
6. ユーザーコードから `str_len("hello")` を呼び出して `5` が返る
7. ユーザーコードから `str_contains("hello", "ell")` を呼び出して `true` が返る
8. 標準ライブラリを使ったサンプルコードが正常に動作する
9. 標準ライブラリ関数のテストが存在し、パスする
10. 既存のテストが引き続きパスする

## 10. Verification Strategy
- **進捗検証**: 各関数実装後に `moca run` でサンプルコードを実行し動作確認
- **達成検証**: 全Acceptance Criteriaをチェックリストで確認、`cargo test` が全てパス
- **漏れ検出**: 標準ライブラリの各関数に対応するテストケースが存在することを確認

## 11. Test Plan

### E2E シナリオ 1: 数学関数の利用
- **Given**: 標準ライブラリが埋め込まれたコンパイラ
- **When**: `print(abs(-10)); print(max(3, 7)); print(min(3, 7));` を含むMocaファイルを実行
- **Then**: `10`, `7`, `3` が順に出力される

### E2E シナリオ 2: 文字列関数の利用
- **Given**: 標準ライブラリが埋め込まれたコンパイラ
- **When**: `print(str_len("hello")); print(str_contains("hello", "ell"));` を含むMocaファイルを実行
- **Then**: `5`, `true` が順に出力される

### E2E シナリオ 3: 既存機能との共存
- **Given**: 標準ライブラリが埋め込まれたコンパイラ
- **When**: 既存のexamplesディレクトリのサンプルを実行
- **Then**: 既存の動作が変わらない（回帰なし）
