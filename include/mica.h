/**
 * @file mica.h
 * @brief Mica VM C API for embedding
 * @version 0.1.0
 *
 * This is the C API for embedding the mica VM in host applications.
 *
 * Basic usage:
 * @code
 * mica_vm *vm = mica_vm_new();
 * if (!vm) {
 *     // Handle allocation failure
 * }
 *
 * // Load bytecode
 * mica_result res = mica_load_chunk(vm, bytecode_data, bytecode_len);
 * if (res != MICA_OK) {
 *     printf("Load error: %s\n", mica_get_error(vm));
 *     mica_vm_free(vm);
 *     return 1;
 * }
 *
 * // Call a function
 * mica_push_i64(vm, 42);  // Push argument
 * res = mica_call(vm, "my_function", 1);  // Call with 1 argument
 * if (res == MICA_OK) {
 *     int64_t result = mica_to_i64(vm, -1);  // Get return value
 *     mica_pop(vm, 1);  // Pop return value
 * }
 *
 * mica_vm_free(vm);
 * @endcode
 */


#ifndef MICA_H
#define MICA_H

/* Warning: This file is auto-generated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Version information
 */
#define MICA_VERSION_MAJOR 0

#define MICA_VERSION_MINOR 1

#define MICA_VERSION_PATCH 0

/**
 * Size of a Value on the stack (128 bits = 16 bytes).
 */
#define VALUE_SIZE 16

/**
 * Size of a Value on the stack (128 bits = 16 bytes).
 */
#define VALUE_SIZE 16

#define TAG_INT 0

#define TAG_INT 0

#define TAG_INT 0

#define TAG_FLOAT 1

#define TAG_FLOAT 1

#define TAG_FLOAT 1

#define TAG_BOOL 2

#define TAG_BOOL 2

#define TAG_BOOL 2

#define TAG_NIL 3

#define TAG_NIL 3

#define TAG_NIL 3

#define TAG_PTR 4

#define TAG_PTR 4

#define TAG_PTR 4

/**
 * Result codes for FFI operations.
 *
 * These map to the `mica_result` enum in C.
 */
typedef enum {
    /**
     * Operation succeeded
     */
    MICA_RESULT_OK = 0,
    /**
     * Runtime error during execution
     */
    MICA_RESULT_ERROR_RUNTIME = 1,
    /**
     * Type mismatch error
     */
    MICA_RESULT_ERROR_TYPE = 2,
    /**
     * Bytecode verification failed
     */
    MICA_RESULT_ERROR_VERIFY = 3,
    /**
     * Out of memory
     */
    MICA_RESULT_ERROR_MEMORY = 4,
    /**
     * Invalid argument passed to function
     */
    MICA_RESULT_ERROR_INVALID_ARG = 5,
    /**
     * Function or global not found
     */
    MICA_RESULT_ERROR_NOT_FOUND = 6,
} MicaResult;

/**
 * Opaque VM instance type.
 *
 * This is the main entry point for the FFI. All operations require
 * a valid `MicaVm` pointer created by `mica_vm_new()`.
 */
typedef struct {
    uint8_t _private[0];
} MicaVm;

/**
 * Error callback function type.
 *
 * Called when an error occurs, with the error message and user data.
 */
typedef void (*MicaErrorFn)(const char *message,
                            void *userdata);

/**
 * Host function type.
 *
 * A C function that can be registered and called from mica code.
 * The function receives the VM instance and should:
 * 1. Read arguments from the stack using `mica_to_*` functions
 * 2. Perform the operation
 * 3. Push the result using `mica_push_*` functions
 * 4. Return `MICA_OK` or an error code
 */
typedef MicaResult (*MicaCFunc)(MicaVm *vm);











































/**
 * Get the version string
 */

const char *mica_version(void)
;

/**
 * Get the major version number
 */

uint32_t mica_version_major(void)
;

/**
 * Get the minor version number
 */

uint32_t mica_version_minor(void)
;

/**
 * Get the patch version number
 */

uint32_t mica_version_patch(void)
;

/**
 * Create a new VM instance.
 *
 * Returns a pointer to a new VM instance, or NULL if allocation fails.
 * The returned VM must be freed with `mica_vm_free()`.
 *
 * # Example (C)
 * ```c
 * mica_vm *vm = mica_vm_new();
 * if (vm == NULL) {
 *     // Handle allocation failure
 * }
 * // ... use vm ...
 * mica_vm_free(vm);
 * ```
 */

MicaVm *mica_vm_new(void)
;

/**
 * Free a VM instance.
 *
 * After this call, the VM pointer is invalid and must not be used.
 *
 * # Safety
 *
 * - `vm` must be a valid pointer returned by `mica_vm_new()`
 * - `vm` must not have been freed already
 * - No other operations may be in progress on this VM
 */

void mica_vm_free(MicaVm *vm)
;

/**
 * Set the memory limit for the VM.
 *
 * This must be called before loading bytecode.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `bytes`: Maximum memory in bytes (0 = no limit)
 */

void mica_set_memory_limit(MicaVm *vm,
                           uintptr_t _bytes)
;

/**
 * Set the error callback function.
 *
 * The callback will be invoked whenever an error occurs.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `callback`: Error callback function (or NULL to disable)
 * - `userdata`: User data passed to callback
 */

void mica_set_error_callback(MicaVm *vm,
                             MicaErrorFn callback,
                             void *userdata)
;

/**
 * Check if the VM has a loaded chunk.
 *
 * Returns true if bytecode has been loaded, false otherwise.
 */

bool mica_has_chunk(MicaVm *vm)
;

/**
 * Push a null value onto the stack.
 */

void mica_push_null(MicaVm *vm)
;

/**
 * Push a boolean value onto the stack.
 */

void mica_push_bool(MicaVm *vm,
                    bool value)
;

/**
 * Push an i64 value onto the stack.
 */

void mica_push_i64(MicaVm *vm,
                   int64_t value)
;

/**
 * Push an f64 value onto the stack.
 */

void mica_push_f64(MicaVm *vm,
                   double value)
;

/**
 * Push a string value onto the stack.
 *
 * The string is copied into the VM's heap. The caller retains ownership
 * of the original string.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `str`: Pointer to string data (does not need to be null-terminated)
 * - `len`: Length of string in bytes
 */

void mica_push_string(MicaVm *vm,
                      const char *str,
                      uintptr_t len)
;

/**
 * Check if the value at the given index is null.
 */

bool mica_is_null(MicaVm *vm,
                  int32_t index)
;

/**
 * Check if the value at the given index is a boolean.
 */

bool mica_is_bool(MicaVm *vm,
                  int32_t index)
;

/**
 * Check if the value at the given index is an i64.
 */

bool mica_is_i64(MicaVm *vm,
                 int32_t index)
;

/**
 * Check if the value at the given index is an f64.
 */

bool mica_is_f64(MicaVm *vm,
                 int32_t index)
;

/**
 * Check if the value at the given index is a string.
 */

bool mica_is_string(MicaVm *vm,
                    int32_t index)
;

/**
 * Check if the value at the given index is a reference (object/array/string).
 */

bool mica_is_ref(MicaVm *vm,
                 int32_t index)
;

/**
 * Get the boolean value at the given index.
 *
 * Returns false if the value is not a boolean or index is invalid.
 */

bool mica_to_bool(MicaVm *vm,
                  int32_t index)
;

/**
 * Get the i64 value at the given index.
 *
 * Returns 0 if the value is not an i64 or index is invalid.
 */

int64_t mica_to_i64(MicaVm *vm,
                    int32_t index)
;

/**
 * Get the f64 value at the given index.
 *
 * Returns 0.0 if the value is not an f64 or index is invalid.
 */

double mica_to_f64(MicaVm *vm,
                   int32_t index)
;

/**
 * Get the string value at the given index.
 *
 * Returns NULL if the value is not a string or index is invalid.
 * The returned pointer is valid until the next GC or stack modification.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `index`: Stack index
 * - `len`: Output parameter for string length (can be NULL)
 */

const char *mica_to_string(MicaVm *vm,
                           int32_t index,
                           uintptr_t *len)
;

/**
 * Pop values from the stack.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `count`: Number of values to pop
 */

void mica_pop(MicaVm *vm,
              int32_t count)
;

/**
 * Get the current stack height.
 *
 * Returns the number of values on the stack.
 */

int32_t mica_get_top(MicaVm *vm)
;

/**
 * Set the stack height.
 *
 * If `index` is less than current height, pops values.
 * If `index` is greater than current height, pushes nulls.
 */

void mica_set_top(MicaVm *vm,
                  int32_t index)
;

/**
 * Call a mica function by name.
 *
 * Arguments must be pushed onto the stack before calling.
 * The result will be on the stack after a successful call.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `func_name`: Name of the function to call (null-terminated)
 * - `nargs`: Number of arguments on the stack
 *
 * # Returns
 * - `MICA_OK` on success
 * - `MICA_ERROR_NOT_FOUND` if function not found
 * - `MICA_ERROR_RUNTIME` on execution error
 */

MicaResult mica_call(MicaVm *vm,
                     const char *func_name,
                     int32_t nargs)
;

/**
 * Protected call - catches errors instead of aborting.
 *
 * Same as `mica_call`, but errors are caught and returned as a result code
 * instead of propagating.
 */

MicaResult mica_pcall(MicaVm *vm,
                      const char *func_name,
                      int32_t nargs)
;

/**
 * Register a host function.
 *
 * The function can then be called from mica code.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `name`: Function name (null-terminated)
 * - `func`: Function pointer
 * - `arity`: Number of arguments the function expects
 */

MicaResult mica_register_function(MicaVm *vm,
                                  const char *name,
                                  MicaCFunc func,
                                  int32_t arity)
;

/**
 * Set a global variable.
 *
 * Pops the top value from the stack and sets it as a global.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `name`: Global variable name (null-terminated)
 */

MicaResult mica_set_global(MicaVm *vm,
                           const char *name)
;

/**
 * Get a global variable.
 *
 * Pushes the global's value onto the stack.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `name`: Global variable name (null-terminated)
 */

MicaResult mica_get_global(MicaVm *vm,
                           const char *name)
;

/**
 * Get the last error message.
 *
 * Returns a pointer to the error message string, or NULL if no error.
 * The returned pointer is valid until the next API call that may set an error.
 *
 * # Example (C)
 * ```c
 * mica_result res = mica_call(vm, "func", 0);
 * if (res != MICA_OK) {
 *     printf("Error: %s\n", mica_get_error(vm));
 * }
 * ```
 */

const char *mica_get_error(const MicaVm *vm)
;

/**
 * Clear the last error.
 *
 * After calling this, `mica_get_error` will return NULL until
 * another error occurs.
 */

void mica_clear_error(MicaVm *vm)
;

/**
 * Check if there is a pending error.
 *
 * Returns true if an error is set, false otherwise.
 */

bool mica_has_error(const MicaVm *vm)
;

#endif  /* MICA_H */
