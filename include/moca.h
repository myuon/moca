/**
 * @file moca.h
 * @brief Moca VM C API for embedding
 * @version 0.1.0
 *
 * This is the C API for embedding the moca VM in host applications.
 *
 * Basic usage:
 * @code
 * moca_vm *vm = moca_vm_new();
 * if (!vm) {
 *     // Handle allocation failure
 * }
 *
 * // Load bytecode
 * moca_result res = moca_load_chunk(vm, bytecode_data, bytecode_len);
 * if (res != MOCA_OK) {
 *     printf("Load error: %s\n", moca_get_error(vm));
 *     moca_vm_free(vm);
 *     return 1;
 * }
 *
 * // Call a function
 * moca_push_i64(vm, 42);  // Push argument
 * res = moca_call(vm, "my_function", 1);  // Call with 1 argument
 * if (res == MOCA_OK) {
 *     int64_t result = moca_to_i64(vm, -1);  // Get return value
 *     moca_pop(vm, 1);  // Pop return value
 * }
 *
 * moca_vm_free(vm);
 * @endcode
 */


#ifndef MOCA_H
#define MOCA_H

/* Warning: This file is auto-generated by cbindgen. Do not modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Version information
 */
#define MOCA_VERSION_MAJOR 0

#define MOCA_VERSION_MINOR 1

#define MOCA_VERSION_PATCH 0

/**
 * Size of a Value on the stack (128 bits = 16 bytes).
 */
#define VALUE_SIZE 16

/**
 * Size of a Value on the stack (128 bits = 16 bytes).
 */
#define VALUE_SIZE 16

#define TAG_INT 0

#define TAG_INT 0

#define TAG_INT 0

#define TAG_FLOAT 1

#define TAG_FLOAT 1

#define TAG_FLOAT 1

#define TAG_BOOL 2

#define TAG_BOOL 2

#define TAG_BOOL 2

#define TAG_NIL 3

#define TAG_NIL 3

#define TAG_NIL 3

#define TAG_PTR 4

#define TAG_PTR 4

#define TAG_PTR 4

/**
 * Current bytecode format version
 */
#define VERSION 2

/**
 * Result codes for FFI operations.
 *
 * These map to the `moca_result` enum in C.
 */
typedef enum {
    /**
     * Operation succeeded
     */
    MOCA_RESULT_OK = 0,
    /**
     * Runtime error during execution
     */
    MOCA_RESULT_ERROR_RUNTIME = 1,
    /**
     * Type mismatch error
     */
    MOCA_RESULT_ERROR_TYPE = 2,
    /**
     * Bytecode verification failed
     */
    MOCA_RESULT_ERROR_VERIFY = 3,
    /**
     * Out of memory
     */
    MOCA_RESULT_ERROR_MEMORY = 4,
    /**
     * Invalid argument passed to function
     */
    MOCA_RESULT_ERROR_INVALID_ARG = 5,
    /**
     * Function or global not found
     */
    MOCA_RESULT_ERROR_NOT_FOUND = 6,
} MocaResult;

/**
 * Opaque VM instance type.
 *
 * This is the main entry point for the FFI. All operations require
 * a valid `MocaVm` pointer created by `moca_vm_new()`.
 */
typedef struct {
    uint8_t _private[0];
} MocaVm;

/**
 * Host function type.
 *
 * A C function that can be registered and called from moca code.
 * The function receives the VM instance and should:
 * 1. Read arguments from the stack using `moca_to_*` functions
 * 2. Perform the operation
 * 3. Push the result using `moca_push_*` functions
 * 4. Return `MOCA_OK` or an error code
 */
typedef MocaResult (*MocaCFunc)(MocaVm *vm);

/**
 * Error callback function type.
 *
 * Called when an error occurs, with the error message and user data.
 */
typedef void (*MocaErrorFn)(const char *message,
                            void *userdata);











































/**
 * Get the version string
 */

const char *moca_version(void)
;

/**
 * Get the major version number
 */

uint32_t moca_version_major(void)
;

/**
 * Get the minor version number
 */

uint32_t moca_version_minor(void)
;

/**
 * Get the patch version number
 */

uint32_t moca_version_patch(void)
;

/**
 * Call a moca function by name.
 *
 * Arguments must be pushed onto the stack before calling.
 * The result will be on the stack after a successful call.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `func_name`: Name of the function to call (null-terminated)
 * - `nargs`: Number of arguments on the stack
 *
 * # Returns
 * - `MOCA_OK` on success
 * - `MOCA_ERROR_NOT_FOUND` if function not found
 * - `MOCA_ERROR_RUNTIME` on execution error
 */

MocaResult moca_call(MocaVm *vm,
                     const char *func_name,
                     int32_t nargs)
;

/**
 * Protected call - catches errors instead of aborting.
 *
 * Same as `moca_call`, but errors are caught and returned as a result code
 * instead of propagating.
 */

MocaResult moca_pcall(MocaVm *vm,
                      const char *func_name,
                      int32_t nargs)
;

/**
 * Register a host function.
 *
 * The function can then be called from moca code.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `name`: Function name (null-terminated)
 * - `func`: Function pointer
 * - `arity`: Number of arguments the function expects
 */

MocaResult moca_register_function(MocaVm *vm,
                                  const char *name,
                                  MocaCFunc func,
                                  int32_t arity)
;

/**
 * Set a global variable.
 *
 * Pops the top value from the stack and sets it as a global.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `name`: Global variable name (null-terminated)
 */

MocaResult moca_set_global(MocaVm *vm,
                           const char *name)
;

/**
 * Get a global variable.
 *
 * Pushes the global's value onto the stack.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `name`: Global variable name (null-terminated)
 */

MocaResult moca_get_global(MocaVm *vm,
                           const char *name)
;

/**
 * Get the last error message.
 *
 * Returns a pointer to the error message string, or NULL if no error.
 * The returned pointer is valid until the next API call that may set an error.
 *
 * # Example (C)
 * ```c
 * moca_result res = moca_call(vm, "func", 0);
 * if (res != MOCA_OK) {
 *     printf("Error: %s\n", moca_get_error(vm));
 * }
 * ```
 */

const char *moca_get_error(const MocaVm *vm)
;

/**
 * Clear the last error.
 *
 * After calling this, `moca_get_error` will return NULL until
 * another error occurs.
 */

void moca_clear_error(MocaVm *vm)
;

/**
 * Check if there is a pending error.
 *
 * Returns true if an error is set, false otherwise.
 */

bool moca_has_error(const MocaVm *vm)
;

/**
 * Load bytecode from memory.
 *
 * This parses and validates the bytecode, making it ready for execution.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `data`: Pointer to bytecode data
 * - `len`: Length of bytecode data in bytes
 *
 * # Returns
 * - `MOCA_OK` on success
 * - `MOCA_ERROR_INVALID_ARG` if data is NULL
 * - `MOCA_ERROR_VERIFY` if bytecode is invalid
 */

MocaResult moca_load_chunk(MocaVm *vm,
                           const uint8_t *data,
                           uintptr_t len)
;

/**
 * Load bytecode from a file.
 *
 * This reads the file, parses the bytecode, and validates it.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `path`: Path to bytecode file (null-terminated)
 *
 * # Returns
 * - `MOCA_OK` on success
 * - `MOCA_ERROR_INVALID_ARG` if path is NULL
 * - `MOCA_ERROR_NOT_FOUND` if file cannot be read
 * - `MOCA_ERROR_VERIFY` if bytecode is invalid
 */

MocaResult moca_load_file(MocaVm *vm,
                          const char *path)
;

/**
 * Save bytecode to a file.
 *
 * This serializes the currently loaded chunk to a file.
 *
 * # Arguments
 * - `vm`: Valid VM instance with a loaded chunk
 * - `path`: Path to output file (null-terminated)
 *
 * # Returns
 * - `MOCA_OK` on success
 * - `MOCA_ERROR_INVALID_ARG` if no chunk is loaded or path is NULL
 * - `MOCA_ERROR_RUNTIME` if file cannot be written
 */

MocaResult moca_save_file(MocaVm *vm,
                          const char *path)
;

/**
 * Push a null value onto the stack.
 */

void moca_push_null(MocaVm *vm)
;

/**
 * Push a boolean value onto the stack.
 */

void moca_push_bool(MocaVm *vm,
                    bool value)
;

/**
 * Push an i64 value onto the stack.
 */

void moca_push_i64(MocaVm *vm,
                   int64_t value)
;

/**
 * Push an f64 value onto the stack.
 */

void moca_push_f64(MocaVm *vm,
                   double value)
;

/**
 * Push a string value onto the stack.
 *
 * The string is copied into the VM's heap. The caller retains ownership
 * of the original string.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `str`: Pointer to string data (does not need to be null-terminated)
 * - `len`: Length of string in bytes
 */

void moca_push_string(MocaVm *vm,
                      const char *str,
                      uintptr_t len)
;

/**
 * Check if the value at the given index is null.
 */

bool moca_is_null(MocaVm *vm,
                  int32_t index)
;

/**
 * Check if the value at the given index is a boolean.
 */

bool moca_is_bool(MocaVm *vm,
                  int32_t index)
;

/**
 * Check if the value at the given index is an i64.
 */

bool moca_is_i64(MocaVm *vm,
                 int32_t index)
;

/**
 * Check if the value at the given index is an f64.
 */

bool moca_is_f64(MocaVm *vm,
                 int32_t index)
;

/**
 * Check if the value at the given index is a string.
 */

bool moca_is_string(MocaVm *vm,
                    int32_t index)
;

/**
 * Check if the value at the given index is a reference (object/array/string).
 */

bool moca_is_ref(MocaVm *vm,
                 int32_t index)
;

/**
 * Get the boolean value at the given index.
 *
 * Returns false if the value is not a boolean or index is invalid.
 */

bool moca_to_bool(MocaVm *vm,
                  int32_t index)
;

/**
 * Get the i64 value at the given index.
 *
 * Returns 0 if the value is not an i64 or index is invalid.
 */

int64_t moca_to_i64(MocaVm *vm,
                    int32_t index)
;

/**
 * Get the f64 value at the given index.
 *
 * Returns 0.0 if the value is not an f64 or index is invalid.
 */

double moca_to_f64(MocaVm *vm,
                   int32_t index)
;

/**
 * Get the string value at the given index.
 *
 * Returns NULL if the value is not a string or index is invalid.
 * The returned pointer is valid until the next GC or stack modification.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `index`: Stack index
 * - `len`: Output parameter for string length (can be NULL)
 */

const char *moca_to_string(MocaVm *vm,
                           int32_t index,
                           uintptr_t *len)
;

/**
 * Pop values from the stack.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `count`: Number of values to pop
 */

void moca_pop(MocaVm *vm,
              int32_t count)
;

/**
 * Get the current stack height.
 *
 * Returns the number of values on the stack.
 */

int32_t moca_get_top(MocaVm *vm)
;

/**
 * Set the stack height.
 *
 * If `index` is less than current height, pops values.
 * If `index` is greater than current height, pushes nulls.
 */

void moca_set_top(MocaVm *vm,
                  int32_t index)
;

/**
 * Create a new VM instance.
 *
 * Returns a pointer to a new VM instance, or NULL if allocation fails.
 * The returned VM must be freed with `moca_vm_free()`.
 *
 * # Example (C)
 * ```c
 * moca_vm *vm = moca_vm_new();
 * if (vm == NULL) {
 *     // Handle allocation failure
 * }
 * // ... use vm ...
 * moca_vm_free(vm);
 * ```
 */

MocaVm *moca_vm_new(void)
;

/**
 * Free a VM instance.
 *
 * After this call, the VM pointer is invalid and must not be used.
 *
 * # Safety
 *
 * - `vm` must be a valid pointer returned by `moca_vm_new()`
 * - `vm` must not have been freed already
 * - No other operations may be in progress on this VM
 */

void moca_vm_free(MocaVm *vm)
;

/**
 * Set the memory limit for the VM.
 *
 * This must be called before loading bytecode.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `bytes`: Maximum memory in bytes (0 = no limit)
 */

void moca_set_memory_limit(MocaVm *vm,
                           uintptr_t _bytes)
;

/**
 * Set the error callback function.
 *
 * The callback will be invoked whenever an error occurs.
 *
 * # Arguments
 * - `vm`: Valid VM instance
 * - `callback`: Error callback function (or NULL to disable)
 * - `userdata`: User data passed to callback
 */

void moca_set_error_callback(MocaVm *vm,
                             MocaErrorFn callback,
                             void *userdata)
;

/**
 * Check if the VM has a loaded chunk.
 *
 * Returns true if bytecode has been loaded, false otherwise.
 */

bool moca_has_chunk(MocaVm *vm)
;

#endif  /* MOCA_H */
